"#line 0 \"osd/mtlPatchGregoryBasis.metal\"\n"
"\n"
"//\n"
"//   Copyright 2015 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryBasis.Hull\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerVertex(\n"
"        float4 position,\n"
"        threadgroup HullVertex& hullVertex,\n"
"        int vertexId,\n"
"        float4x4 modelViewProjectionMatrix,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    hullVertex.position = position;\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    float4 clipPos = mul(modelViewProjectionMatrix, position);\n"
"    short3 clip0 = short3(clipPos.x < clipPos.w,\n"
"                          clipPos.y < clipPos.w,\n"
"                          clipPos.z < clipPos.w);\n"
"    short3 clip1 = short3(clipPos.x > -clipPos.w,\n"
"                          clipPos.y > -clipPos.w,\n"
"                          clipPos.z > -clipPos.w);\n"
"    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);\n"
"#endif\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryBasis.Factors\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchGregoryFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"#if !USE_PTVS_FACTORS\n"
"        device OsdPerPatchTessFactors& patchFactors,\n"
"#endif\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    float4 tessLevelOuter = float4(0);\n"
"    float2 tessLevelInner = float2(0);\n"
"    float4 tessOuterLo = float4(0);\n"
"    float4 tessOuterHi = float4(0);\n"
"\n"
"#if OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    // Gather bezier control points to compute limit surface tess levels\n"
"    float3 bezcv[16];\n"
"    bezcv[ 0] = patchVertices[ 0].position.xyz;\n"
"    bezcv[ 1] = patchVertices[ 1].position.xyz;\n"
"    bezcv[ 2] = patchVertices[ 7].position.xyz;\n"
"    bezcv[ 3] = patchVertices[ 5].position.xyz;\n"
"    bezcv[ 4] = patchVertices[ 2].position.xyz;\n"
"    bezcv[ 5] = patchVertices[ 3].position.xyz;\n"
"    bezcv[ 6] = patchVertices[ 8].position.xyz;\n"
"    bezcv[ 7] = patchVertices[ 6].position.xyz;\n"
"    bezcv[ 8] = patchVertices[16].position.xyz;\n"
"    bezcv[ 9] = patchVertices[18].position.xyz;\n"
"    bezcv[10] = patchVertices[13].position.xyz;\n"
"    bezcv[11] = patchVertices[12].position.xyz;\n"
"    bezcv[12] = patchVertices[15].position.xyz;\n"
"    bezcv[13] = patchVertices[17].position.xyz;\n"
"    bezcv[14] = patchVertices[11].position.xyz;\n"
"    bezcv[15] = patchVertices[10].position.xyz;\n"
"\n"
"    OsdEvalPatchBezierTessLevels(\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        bezcv,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#else\n"
"    OsdGetTessLevelsUniform(\n"
"        tessLevel,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#endif\n"
"\n"
"    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];\n"
"    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];\n"
"    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];\n"
"    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];\n"
"    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];\n"
"    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];\n"
"#if !USE_PTVS_FACTORS\n"
"    patchFactors.tessOuterLo = tessOuterLo;\n"
"    patchFactors.tessOuterHi = tessOuterHi;\n"
"#endif\n"
"}\n"
"\n"
"void OsdComputePerPatchFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        unsigned patchID,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        OsdPatchParamBufferSet osdBuffer,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    OsdComputePerPatchGregoryFactors(\n"
"        patchParam,\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        patchVertices,\n"
"#if !USE_PTVS_FACTORS\n"
"        osdBuffer.patchTessBuffer[patchID],\n"
"#endif\n"
"        quadFactors\n"
"        );\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryBasis.Vertex\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchVertex(\n"
"        int3 patchParam,\n"
"        unsigned ID,\n"
"        unsigned PrimitiveID,\n"
"        unsigned ControlID,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    //Does nothing, all transforms are in the PTVS\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryBasis.Domain\n"
"//----------------------------------------------------------\n"
"\n"
"#define USE_128BIT_GREGORY_BASIS_INDICES_READ 1\n"
"\n"
"\n"
"#if USE_STAGE_IN\n"
"template<typename PerPatchVertexGregoryBasis>\n"
"#endif\n"
"OsdPatchVertex ds_gregory_basis_patches(\n"
"        const float tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"        float4 tessOuterLo,\n"
"        float4 tessOuterHi,\n"
"#endif\n"
"#if USE_STAGE_IN\n"
"        PerPatchVertexGregoryBasis patch,\n"
"#else\n"
"        const device OsdInputVertexType* patch,\n"
"        const device unsigned* patchIndices,\n"
"#endif\n"
"        int3 patchParam,\n"
"        float2 domainCoord\n"
"        )\n"
"{\n"
"#if USE_STAGE_IN\n"
"    float3 cv[20];\n"
"    for(int i = 0; i < 20; i++)\n"
"        cv[i] = patch[i].position;\n"
"#else\n"
"#if USE_128BIT_GREGORY_BASIS_INDICES_READ\n"
"    float3 cv[20];\n"
"    for(int i = 0; i < 5; i++) {\n"
"        int4 indices = ((device int4*)patchIndices)[i];\n"
"\n"
"        int n = i * 4;\n"
"        cv[n + 0] = (patch + indices[0])->position;\n"
"        cv[n + 1] = (patch + indices[1])->position;\n"
"        cv[n + 2] = (patch + indices[2])->position;\n"
"        cv[n + 3] = (patch + indices[3])->position;\n"
"    }\n"
"#else\n"
"    float3 cv[20];\n"
"    for (int i = 0; i < 20; ++i) {\n"
"        cv[i] = patch[patchIndices[i]].position;\n"
"    }\n"
"#endif\n"
"#endif\n"
"\n"
"#if USE_PTVS_FACTORS\n"
"    float4 tessOuterLo(0), tessOuterHi(0);\n"
"    OsdGetTessLevelsUniform(tessLevel, patchParam, tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"    float2 UV = OsdGetTessParameterization(domainCoord,\n"
"                                           tessOuterLo,\n"
"                                           tessOuterHi);\n"
"\n"
"    OsdPatchVertex output;\n"
"\n"
"    float3 P = float3(0), dPu = float3(0), dPv = float3(0);\n"
"    float3 N = float3(0), dNu = float3(0), dNv = float3(0);\n"
"\n"
"    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    output.position = P;\n"
"    output.normal = N;\n"
"    output.tangent = dPu;\n"
"    output.bitangent = dPv;\n"
"#if OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    output.Nu = dNu;\n"
"    output.Nv = dNv;\n"
"#endif\n"
"\n"
"    output.tessCoord = UV;\n"
"    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);\n"
"\n"
"    return output;\n"
"}\n"
"\n"
"#if USE_STAGE_IN\n"
"template<typename PerPatchVertexGregoryBasis>\n"
"#endif\n"
"OsdPatchVertex OsdComputePatch(\n"
"        float tessLevel,\n"
"        float2 domainCoord,\n"
"        unsigned patchID,\n"
"#if USE_STAGE_IN\n"
"        PerPatchVertexGregoryBasis osdPatch\n"
"#else\n"
"        OsdVertexBufferSet osdBuffers\n"
"#endif\n"
"        )\n"
"{\n"
"    return ds_gregory_basis_patches(\n"
"            tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"#if USE_STAGE_IN\n"
"            osdPatch.tessOuterLo,\n"
"            osdPatch.tessOuterHi,\n"
"#else\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterLo,\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterHi,\n"
"#endif\n"
"#endif\n"
"#if USE_STAGE_IN\n"
"            osdPatch.cv,\n"
"            osdPatch.patchParam,\n"
"#else\n"
"            osdBuffers.vertexBuffer,\n"
"            osdBuffers.indexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"            osdBuffers.patchParamBuffer[patchID],\n"
"#endif\n"
"            domainCoord\n"
"            );\n"
"}\n"
"\n"
