"#line 0 \"osd/mtlPatchBoxSplineTriangle.metal\"\n"
"\n"
"//\n"
"//   Copyright 2015-2019 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Common\n"
"//----------------------------------------------------------\n"
"\n"
"#define offsetof_(X, Y) &(((device X*)nullptr)->Y)\n"
"\n"
"#define OSD_IS_ADAPTIVE (OSD_PATCH_REGULAR || OSD_PATCH_BOX_SPLINE_TRIANGLE || OSD_PATCH_GREGORY_BASIS || OSD_PATCH_GREGORY_TRIANGLE || OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY)\n"
"\n"
"#ifndef OSD_NUM_ELEMENTS\n"
"#define OSD_NUM_ELEMENTS 3\n"
"#endif\n"
"\n"
"struct OsdPerVertexGregory {\n"
"    float3 P;\n"
"    short3 clipFlag;\n"
"    int valence;\n"
"    float3 e0;\n"
"    float3 e1;\n"
"#if OSD_PATCH_GREGORY_BOUNDARY\n"
"    int zerothNeighbor;\n"
"    float3 org;\n"
"#endif\n"
"    float3 r[OSD_MAX_VALENCE];\n"
"};\n"
"\n"
"struct OsdPerPatchVertexGregory {\n"
"    packed_float3 P;\n"
"    packed_float3 Ep;\n"
"    packed_float3 Em;\n"
"    packed_float3 Fp;\n"
"    packed_float3 Fm;\n"
"};\n"
"\n"
"//----------------------------------------------------------\n"
"// HLSL->Metal Compatibility\n"
"//----------------------------------------------------------\n"
"\n"
"float4 mul(float4x4 a, float4 b)\n"
"{\n"
"    return a * b;\n"
"}\n"
"\n"
"float3 mul(float4x4 a, float3 b)\n"
"{\n"
"    float3x3 m(a[0].xyz, a[1].xyz, a[2].xyz);\n"
"    return m * b;\n"
"\n"
"}\n"
"\n"
"struct HullVertex {\n"
"    float4 position;\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    short3 clipFlag;\n"
"#endif\n"
"\n"
"    float3 GetPosition() threadgroup\n"
"    {\n"
"        return position.xyz;\n"
"    }\n"
"\n"
"    void SetPosition(float3 v) threadgroup\n"
"    {\n"
"        position.xyz = v;\n"
"    }\n"
"};\n"
"\n"
"// XXXdyu all downstream data can be handled by client code\n"
"struct OsdPatchVertex {\n"
"    float3 position;\n"
"    float3 normal;\n"
"    float3 tangent;\n"
"    float3 bitangent;\n"
"    float4 patchCoord; //u, v, faceLevel, faceId\n"
"    float2 tessCoord; // tesscoord.st\n"
"#if OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    float3 Nu;\n"
"    float3 Nv;\n"
"#endif\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    float2 vSegments;\n"
"#endif\n"
"};\n"
"\n"
"struct OsdPerPatchTessFactors {\n"
"    float4 tessOuterLo;\n"
"    float4 tessOuterHi;\n"
"};\n"
"\n"
"using OsdPatchParamBufferType = packed_int3;\n"
"\n"
"#if OSD_PATCH_REGULAR || OSD_PATCH_BOX_SPLINE_TRIANGLE\n"
"using PatchVertexType = HullVertex;\n"
"using PerPatchVertexType = OsdPerPatchVertexBezier;\n"
"#elif OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY\n"
"using PatchVertexType = OsdPerVertexGregory;\n"
"using PerPatchVertexType = OsdPerPatchVertexGregory;\n"
"#elif OSD_PATCH_GREGORY_BASIS || OSD_PATCH_GREGORY_TRIANGLE\n"
"using PatchVertexType = HullVertex;\n"
"using PerPatchVertexType = OsdPerPatchVertexGregoryBasis;\n"
"#else\n"
"using PatchVertexType = OsdInputVertexType;\n"
"using PerPatchVertexType = OsdInputVertexType;\n"
"#endif\n"
"\n"
"//Shared buffers used by OSD that are common to all kernels\n"
"struct OsdPatchParamBufferSet\n"
"{\n"
"    const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];\n"
"    const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];\n"
"\n"
"    const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];\n"
"\n"
"    device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEX_BUFFER_INDEX)]];\n"
"\n"
"#if !USE_PTVS_FACTORS\n"
"    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];\n"
"#endif\n"
"\n"
"#if OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY\n"
"    const device int* quadOffsetBuffer [[buffer(OSD_QUADOFFSET_BUFFER_INDEX)]];\n"
"    const device int* valenceBuffer [[buffer(OSD_VALENCE_BUFFER_INDEX)]];\n"
"#endif\n"
"\n"
"    const constant unsigned& kernelExecutionLimit [[buffer(OSD_KERNELLIMIT_BUFFER_INDEX)]];\n"
"};\n"
"\n"
"//Shared buffers used by OSD that are common to all PTVS implementations\n"
"struct OsdVertexBufferSet\n"
"{\n"
"    const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];\n"
"    const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];\n"
"\n"
"    const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];\n"
"\n"
"    device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEX_BUFFER_INDEX)]];\n"
"\n"
"#if !USE_PTVS_FACTORS\n"
"    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];\n"
"#endif\n"
"};\n"
"\n"
"// These are stored in OsdPatchParamBuffer indexed by the value returned\n"
"// from OsdGetPatchIndex() which is a function of the current PrimitiveID\n"
"// along with an optional client provided offset.\n"
"\n"
"int3 OsdGetPatchParam(int patchIndex, const device OsdPatchParamBufferType* osdPatchParamBuffer)\n"
"{\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    return int3(osdPatchParamBuffer[patchIndex]);\n"
"#else\n"
"    auto p = osdPatchParamBuffer[patchIndex];\n"
"    return int3(p[0], p[1], 0);\n"
"#endif\n"
"}\n"
"\n"
"int OsdGetPatchIndex(int primitiveId)\n"
"{\n"
"    return primitiveId;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// patch culling\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"bool OsdCullPerPatchVertex(\n"
"        threadgroup PatchVertexType* patch,\n"
"        float4x4 ModelViewMatrix\n"
"        )\n"
"{\n"
"#if OSD_ENABLE_BACKPATCH_CULL && OSD_PATCH_REGULAR\n"
"    auto v0 = float3(ModelViewMatrix * patch[5].position);\n"
"    auto v3 = float3(ModelViewMatrix * patch[6].position);\n"
"    auto v12 = float3(ModelViewMatrix * patch[9].position);\n"
"\n"
"    auto n = normalize(cross(v3 - v0, v12 - v0));\n"
"    v0 = normalize(v0 + v3 + v12);\n"
"\n"
"    if(dot(v0, n) > 0.6f)\n"
"    {\n"
"        return false;\n"
"    }\n"
"#endif\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    short3 clipFlag = short3(0,0,0);\n"
"    for(int i = 0; i < CONTROL_POINTS_PER_PATCH; ++i) {\n"
"        clipFlag |= patch[i].clipFlag;\n"
"    }\n"
"    if (any(clipFlag != short3(3,3,3))) {\n"
"        return false;\n"
"    }\n"
"#endif\n"
"    return true;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Legacy Gregory\n"
"// ----------------------------------------------------------------------------\n"
"#if defined(OSD_PATCH_GREGORY) || defined(OSD_PATCH_GREGORY_BOUNDARY)\n"
"\n"
"// precomputed catmark coefficient table up to valence 29\n"
"constant float OsdCatmarkCoefficient[30] = {\n"
"    0, 0, 0, 0.812816, 0.500000, 0.363644, 0.287514,\n"
"    0.238688, 0.204544, 0.179229, 0.159657,\n"
"    0.144042, 0.131276, 0.120632, 0.111614,\n"
"    0.103872, 0.09715, 0.0912559, 0.0860444,\n"
"    0.0814022, 0.0772401, 0.0734867, 0.0700842,\n"
"    0.0669851, 0.0641504, 0.0615475, 0.0591488,\n"
"    0.0569311, 0.0548745, 0.0529621\n"
"};\n"
"\n"
"float\n"
"OsdComputeCatmarkCoefficient(int valence)\n"
"{\n"
"#if OSD_MAX_VALENCE < 30\n"
"    return OsdCatmarkCoefficient[valence];\n"
"#else\n"
"    if (valence < 30) {\n"
"        return OsdCatmarkCoefficient[valence];\n"
"    } else {\n"
"        float t = 2.0f / float(valence);\n"
"        return 1.0f / (valence * (cospi(t) + 5.0f +\n"
"                                  sqrt((cospi(t) + 9) * (cospi(t) + 1)))/16.0f);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"float cosfn(int n, int j) {\n"
"    return cospi((2.0f * j)/float(n));\n"
"}\n"
"\n"
"float sinfn(int n, int j) {\n"
"    return sinpi((2.0f * j)/float(n));\n"
"}\n"
"\n"
"#ifndef OSD_MAX_VALENCE\n"
"#define OSD_MAX_VALENCE 4\n"
"#endif\n"
"\n"
"template<typename OsdVertexBuffer>\n"
"float3 OsdReadVertex(int vertexIndex, OsdVertexBuffer osdVertexBuffer)\n"
"{\n"
"    int index = (vertexIndex /*+ OsdBaseVertex()*/);\n"
"    return osdVertexBuffer[index].position;\n"
"}\n"
"\n"
"template<typename OsdValenceBuffer>\n"
"int OsdReadVertexValence(int vertexID, OsdValenceBuffer osdValenceBuffer)\n"
"{\n"
"    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1));\n"
"    return osdValenceBuffer[index];\n"
"}\n"
"\n"
"template<typename OsdValenceBuffer>\n"
"int OsdReadVertexIndex(int vertexID, int valenceVertex, OsdValenceBuffer osdValenceBuffer)\n"
"{\n"
"    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1) + 1 + valenceVertex);\n"
"    return osdValenceBuffer[index];\n"
"}\n"
"\n"
"template<typename OsdQuadOffsetBuffer>\n"
"int OsdReadQuadOffset(int primitiveID, int offsetVertex, OsdQuadOffsetBuffer osdQuadOffsetBuffer)\n"
"{\n"
"    int index = int(4*primitiveID + offsetVertex);\n"
"    return osdQuadOffsetBuffer[index];\n"
"}\n"
"\n"
"\n"
"void OsdComputePerVertexGregory(unsigned vID, float3 P, threadgroup OsdPerVertexGregory& v, OsdPatchParamBufferSet osdBuffers)\n"
"{\n"
"    v.clipFlag = short3(0,0,0);\n"
"\n"
"    int ivalence = OsdReadVertexValence(vID, osdBuffers.valenceBuffer);\n"
"    v.valence = ivalence;\n"
"    int valence = abs(ivalence);\n"
"\n"
"    float3 f[OSD_MAX_VALENCE];\n"
"    float3 pos = P;\n"
"    float3 opos = float3(0,0,0);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    v.org = pos;\n"
"    int boundaryEdgeNeighbors[2];\n"
"    int currNeighbor = 0;\n"
"    int ibefore = 0;\n"
"    int zerothNeighbor = 0;\n"
"#endif\n"
"\n"
"    for (int i=0; i<valence; ++i) {\n"
"        int im = (i+valence-1)%valence;\n"
"        int ip = (i+1)%valence;\n"
"\n"
"        int idx_neighbor = OsdReadVertexIndex(vID, 2*i, osdBuffers.valenceBuffer);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"        bool isBoundaryNeighbor = false;\n"
"        int valenceNeighbor = OsdReadVertexValence(idx_neighbor, osdBuffers.valenceBuffer);\n"
"\n"
"        if (valenceNeighbor < 0) {\n"
"            isBoundaryNeighbor = true;\n"
"            if (currNeighbor<2) {\n"
"                boundaryEdgeNeighbors[currNeighbor] = idx_neighbor;\n"
"            }\n"
"            currNeighbor++;\n"
"            if (currNeighbor == 1) {\n"
"                ibefore = i;\n"
"                zerothNeighbor = i;\n"
"            } else {\n"
"                if (i-ibefore == 1) {\n"
"                    int tmp = boundaryEdgeNeighbors[0];\n"
"                    boundaryEdgeNeighbors[0] = boundaryEdgeNeighbors[1];\n"
"                    boundaryEdgeNeighbors[1] = tmp;\n"
"                    zerothNeighbor = i;\n"
"                }\n"
"            }\n"
"        }\n"
"#endif\n"
"\n"
"        float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);\n"
"\n"
"        int idx_diagonal = OsdReadVertexIndex(vID, 2*i + 1, osdBuffers.valenceBuffer);\n"
"        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);\n"
"\n"
"        int idx_neighbor_p = OsdReadVertexIndex(vID, 2*ip, osdBuffers.valenceBuffer);\n"
"        float3 neighbor_p = OsdReadVertex(idx_neighbor_p, osdBuffers.vertexBuffer);\n"
"\n"
"        int idx_neighbor_m = OsdReadVertexIndex(vID, 2*im, osdBuffers.valenceBuffer);\n"
"        float3 neighbor_m = OsdReadVertex(idx_neighbor_m, osdBuffers.vertexBuffer);\n"
"\n"
"        int idx_diagonal_m = OsdReadVertexIndex(vID, 2*im + 1, osdBuffers.valenceBuffer);\n"
"        float3 diagonal_m = OsdReadVertex(idx_diagonal_m, osdBuffers.vertexBuffer);\n"
"\n"
"        f[i] = (pos * float(valence) + (neighbor_p + neighbor)*2.0f + diagonal) / (float(valence)+5.0f);\n"
"\n"
"        opos += f[i];\n"
"        v.r[i] = (neighbor_p-neighbor_m)/3.0f + (diagonal - diagonal_m)/6.0f;\n"
"    }\n"
"\n"
"    opos /= valence;\n"
"    v.P = float4(opos, 1.0f).xyz;\n"
"\n"
"    float3 e;\n"
"    v.e0 = float3(0,0,0);\n"
"    v.e1 = float3(0,0,0);\n"
"\n"
"    for(int i=0; i<valence; ++i) {\n"
"        int im = (i + valence -1) % valence;\n"
"        e = 0.5f * (f[i] + f[im]);\n"
"        v.e0 += cosfn(valence, i)*e;\n"
"        v.e1 += sinfn(valence, i)*e;\n"
"    }\n"
"    float ef = OsdComputeCatmarkCoefficient(valence);\n"
"    v.e0 *= ef;\n"
"    v.e1 *= ef;\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    v.zerothNeighbor = zerothNeighbor;\n"
"    if (currNeighbor == 1) {\n"
"        boundaryEdgeNeighbors[1] = boundaryEdgeNeighbors[0];\n"
"    }\n"
"\n"
"    if (ivalence < 0) {\n"
"        if (valence > 2) {\n"
"            v.P = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +\n"
"                   OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +\n"
"                   4.0f * pos)/6.0f;\n"
"        } else {\n"
"            v.P = pos;\n"
"        }\n"
"\n"
"        v.e0 = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) -\n"
"                OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer))/6.0;\n"
"\n"
"        float k = float(float(valence) - 1.0f);    //k is the number of faces\n"
"        float c = cospi(1.0/k);\n"
"        float s = sinpi(1.0/k);\n"
"        float gamma = -(4.0f*s)/(3.0f*k+c);\n"
"        float alpha_0k = -((1.0f+2.0f*c)*sqrt(1.0f+c))/((3.0f*k+c)*sqrt(1.0f-c));\n"
"        float beta_0 = s/(3.0f*k + c);\n"
"\n"
"        int idx_diagonal = OsdReadVertexIndex(vID, 2*zerothNeighbor + 1, osdBuffers.valenceBuffer);\n"
"        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);\n"
"\n"
"        v.e1 = gamma * pos +\n"
"            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +\n"
"            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +\n"
"            beta_0 * diagonal;\n"
"\n"
"        for (int x=1; x<valence - 1; ++x) {\n"
"            int curri = ((x + zerothNeighbor)%valence);\n"
"            float alpha = (4.0f*sinpi((float(x))/k))/(3.0f*k+c);\n"
"            float beta = (sinpi((float(x))/k) + sinpi((float(x+1))/k))/(3.0f*k+c);\n"
"\n"
"            int idx_neighbor = OsdReadVertexIndex(vID, 2*curri, osdBuffers.valenceBuffer);\n"
"            float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);\n"
"\n"
"            idx_diagonal = OsdReadVertexIndex(vID, 2*curri + 1, osdBuffers.valenceBuffer);\n"
"            diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);\n"
"\n"
"            v.e1 += alpha * neighbor + beta * diagonal;\n"
"        }\n"
"\n"
"        v.e1 /= 3.0f;\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void\n"
"OsdComputePerPatchVertexGregory(int3 patchParam, unsigned ID, unsigned primitiveID,\n"
"                                threadgroup OsdPerVertexGregory* v,\n"
"                                device OsdPerPatchVertexGregory& result,\n"
"                                OsdPatchParamBufferSet osdBuffers)\n"
"{\n"
"    result.P = v[ID].P;\n"
"\n"
"    int i = ID;\n"
"    int ip = (i+1)%4;\n"
"    int im = (i+3)%4;\n"
"    int valence = abs(v[i].valence);\n"
"    int n = valence;\n"
"\n"
"    int start = OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) & 0xff;\n"
"    int prev = (OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;\n"
"\n"
"    int start_m = OsdReadQuadOffset(primitiveID, im, osdBuffers.quadOffsetBuffer) & 0xff;\n"
"    int prev_p = (OsdReadQuadOffset(primitiveID, ip, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;\n"
"\n"
"    int np = abs(v[ip].valence);\n"
"    int nm = abs(v[im].valence);\n"
"\n"
"    // Control Vertices based on :\n"
"    // \"Approximating Subdivision Surfaces with Gregory Patches\n"
"    //  for Hardware Tessellation\"\n"
"    // Loop, Schaefer, Ni, Castano (ACM ToG Siggraph Asia 2009)\n"
"    //\n"
"    //  P3         e3-      e2+         P2\n"
"    //     O--------O--------O--------O\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     |        | f3-    | f2+    |\n"
"    //     |        O        O        |\n"
"    // e3+ O------O            O------O e2-\n"
"    //     |     f3+          f2-     |\n"
"    //     |                          |\n"
"    //     |                          |\n"
"    //     |      f0-         f1+     |\n"
"    // e0- O------O            O------O e1+\n"
"    //     |        O        O        |\n"
"    //     |        | f0+    | f1-    |\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     O--------O--------O--------O\n"
"    //  P0         e0+      e1-         P1\n"
"    //\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    float3 Em_ip;\n"
"    if (v[ip].valence < -2) {\n"
"        int j = (np + prev_p - v[ip].zerothNeighbor) % np;\n"
"        Em_ip = v[ip].P + cospi(j/float(np-1))*v[ip].e0 + sinpi(j/float(np-1))*v[ip].e1;\n"
"    } else {\n"
"        Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);\n"
"    }\n"
"\n"
"    float3 Ep_im;\n"
"    if (v[im].valence < -2) {\n"
"        int j = (nm + start_m - v[im].zerothNeighbor) % nm;\n"
"        Ep_im = v[im].P + cospi(j/float(nm-1))*v[im].e0 + sinpi(j/float(nm-1))*v[im].e1;\n"
"    } else {\n"
"        Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);\n"
"    }\n"
"\n"
"    if (v[i].valence < 0) {\n"
"        n = (n-1)*2;\n"
"    }\n"
"    if (v[im].valence < 0) {\n"
"        nm = (nm-1)*2;\n"
"    }\n"
"    if (v[ip].valence < 0) {\n"
"        np = (np-1)*2;\n"
"    }\n"
"\n"
"    if (v[i].valence > 2) {\n"
"        result.Ep = v[i].P + (v[i].e0*cosfn(n, start) + v[i].e1*sinfn(n, start));\n"
"        result.Em = v[i].P + (v[i].e0*cosfn(n, prev) +  v[i].e1*sinfn(n, prev));\n"
"\n"
"        float s1=3-2*cosfn(n,1)-cosfn(np,1);\n"
"        float s2=2*cosfn(n,1);\n"
"\n"
"        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));\n"
"        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"\n"
"    } else if (v[i].valence < -2) {\n"
"        int j = (valence + start - v[i].zerothNeighbor) % valence;\n"
"\n"
"        result.Ep = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;\n"
"        j = (valence + prev - v[i].zerothNeighbor) % valence;\n"
"        result.Em = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;\n"
"\n"
"        float3 Rp = ((-2.0f * v[i].org - 1.0f * v[im].org) + (2.0f * v[ip].org + 1.0f * v[(i+2)%4].org))/3.0f;\n"
"        float3 Rm = ((-2.0f * v[i].org - 1.0f * v[ip].org) + (2.0f * v[im].org + 1.0f * v[(i+2)%4].org))/3.0f;\n"
"\n"
"        float s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"        float s2 = 2*cosfn(n,1);\n"
"\n"
"        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));\n"
"        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"\n"
"        if (v[im].valence < 0) {\n"
"            s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"            result.Fp = result.Fm = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        } else if (v[ip].valence < 0) {\n"
"            s1 = 3.0f-2.0f*cospi(2.0f/n)-cospi(2.0f/nm);\n"
"            result.Fm = result.Fp = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"        }\n"
"\n"
"    } else if (v[i].valence == -2) {\n"
"        result.Ep = (2.0f * v[i].org + v[ip].org)/3.0f;\n"
"        result.Em = (2.0f * v[i].org + v[im].org)/3.0f;\n"
"        result.Fp = result.Fm = (4.0f * v[i].org + v[(i+2)%n].org + 2.0f * v[ip].org + 2.0f * v[im].org)/9.0f;\n"
"    }\n"
"\n"
"#else // not OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
"    result.Ep = v[i].P + v[i].e0 * cosfn(n, start) + v[i].e1*sinfn(n, start);\n"
"    result.Em = v[i].P + v[i].e0 * cosfn(n, prev ) + v[i].e1*sinfn(n, prev );\n"
"\n"
"    float3 Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);\n"
"    float3 Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);\n"
"\n"
"    float s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"    float s2 = 2*cosfn(n,1);\n"
"\n"
"    result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"    s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));\n"
"    result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em +s2*Ep_im - v[i].r[prev])/3.0f;\n"
"#endif\n"
"}\n"
"\n"
"#endif  // OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
