"#line 0 \"osd/mtlPatchGregory.metal\"\n"
"\n"
"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Gregory.Hull\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerVertex(\n"
"        float4 position,\n"
"        threadgroup OsdPerVertexGregory& hullVertex,\n"
"        int vertexId,\n"
"        float4x4 modelViewProjectionMatrix,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    OsdComputePerVertexGregory(vertexId, position.xyz, hullVertex, osdBuffers);\n"
"\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    float4 clipPos = mul(modelViewProjectionMatrix, position);\n"
"    short3 clip0 = short3(clipPos.x < clipPos.w,\n"
"                          clipPos.y < clipPos.w,\n"
"                          clipPos.z < clipPos.w);\n"
"    short3 clip1 = short3(clipPos.x > -clipPos.w,\n"
"                          clipPos.y > -clipPos.w,\n"
"                          clipPos.z > -clipPos.w);\n"
"    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);\n"
"#endif\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Gregory.Factors\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchGregoryFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        device OsdPerPatchVertexGregory* patchVertices,\n"
"#if !USE_PTVS_FACTORS\n"
"        device OsdPerPatchTessFactors& patchFactors,\n"
"#endif\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    float4 tessLevelOuter = float4(0);\n"
"    float2 tessLevelInner = float2(0);\n"
"    float4 tessOuterLo = float4(0);\n"
"    float4 tessOuterHi = float4(0);\n"
"\n"
"#if OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    // Gather bezier control points to compute limit surface tess levels\n"
"    float3 bezcv[16];\n"
"    bezcv[ 0] = patchVertices[0].P;\n"
"    bezcv[ 1] = patchVertices[0].Ep;\n"
"    bezcv[ 2] = patchVertices[1].Em;\n"
"    bezcv[ 3] = patchVertices[1].P;\n"
"    bezcv[ 4] = patchVertices[0].Em;\n"
"    bezcv[ 5] = patchVertices[0].Fp;\n"
"    bezcv[ 6] = patchVertices[1].Fm;\n"
"    bezcv[ 7] = patchVertices[1].Ep;\n"
"    bezcv[ 8] = patchVertices[3].Ep;\n"
"    bezcv[ 9] = patchVertices[3].Fm;\n"
"    bezcv[10] = patchVertices[2].Fp;\n"
"    bezcv[11] = patchVertices[2].Em;\n"
"    bezcv[12] = patchVertices[3].P;\n"
"    bezcv[13] = patchVertices[3].Em;\n"
"    bezcv[14] = patchVertices[2].Ep;\n"
"    bezcv[15] = patchVertices[2].P;\n"
"\n"
"    OsdEvalPatchBezierTessLevels(\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        bezcv,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#else\n"
"    OsdGetTessLevelsUniform(\n"
"        tessLevel,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#endif\n"
"\n"
"    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];\n"
"    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];\n"
"    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];\n"
"    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];\n"
"    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];\n"
"    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];\n"
"#if !USE_PTVS_FACTORS\n"
"    patchFactors.tessOuterLo = tessOuterLo;\n"
"    patchFactors.tessOuterHi = tessOuterHi;\n"
"#endif\n"
"}\n"
"\n"
"void OsdComputePerPatchFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        unsigned patchID,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        OsdPatchParamBufferSet osdBuffer,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    OsdComputePerPatchGregoryFactors(\n"
"        patchParam,\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        osdBuffer.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"#if !USE_PTVS_FACTORS\n"
"        osdBuffer.patchTessBuffer[patchID],\n"
"#endif\n"
"        quadFactors\n"
"        );\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Gregory.Vertex\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchVertex(\n"
"        int3 patchParam,\n"
"        unsigned ID,\n"
"        unsigned PrimitiveID,\n"
"        unsigned ControlID,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    OsdComputePerPatchVertexGregory(\n"
"            patchParam,\n"
"            ID,\n"
"            PrimitiveID,\n"
"            patchVertices,\n"
"            osdBuffers.perPatchVertexBuffer[ControlID],\n"
"            osdBuffers);\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Gregory.Domain\n"
"//----------------------------------------------------------\n"
"\n"
"template<typename PerPatchVertexGregory>\n"
"OsdPatchVertex ds_gregory_patches(\n"
"        const float tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"        float4 tessOuterLo,\n"
"        float4 tessOuterHi,\n"
"#endif\n"
"        PerPatchVertexGregory patch,\n"
"        int3 patchParam,\n"
"        float2 domainCoord\n"
"        )\n"
"{\n"
"    float3 cv[20];\n"
"    cv[0] = patch[0].P;\n"
"    cv[1] = patch[0].Ep;\n"
"    cv[2] = patch[0].Em;\n"
"    cv[3] = patch[0].Fp;\n"
"    cv[4] = patch[0].Fm;\n"
"    cv[5] = patch[1].P;\n"
"    cv[6] = patch[1].Ep;\n"
"    cv[7] = patch[1].Em;\n"
"    cv[8] = patch[1].Fp;\n"
"    cv[9] = patch[1].Fm;\n"
"    cv[10] = patch[2].P;\n"
"    cv[11] = patch[2].Ep;\n"
"    cv[12] = patch[2].Em;\n"
"    cv[13] = patch[2].Fp;\n"
"    cv[14] = patch[2].Fm;\n"
"    cv[15] = patch[3].P;\n"
"    cv[16] = patch[3].Ep;\n"
"    cv[17] = patch[3].Em;\n"
"    cv[18] = patch[3].Fp;\n"
"    cv[19] = patch[3].Fm;\n"
"\n"
"#if USE_PTVS_FACTORS\n"
"    float4 tessOuterLo(0), tessOuterHi(0);\n"
"    OsdGetTessLevelsUniform(tessLevel, patchParam, tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"    float2 UV = OsdGetTessParameterization(domainCoord,\n"
"                                           tessOuterLo,\n"
"                                           tessOuterHi);\n"
"\n"
"    OsdPatchVertex output;\n"
"\n"
"    float3 P = float3(0), dPu = float3(0), dPv = float3(0);\n"
"    float3 N = float3(0), dNu = float3(0), dNv = float3(0);\n"
"\n"
"    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    // all code below here is client code\n"
"    output.position = P;\n"
"    output.normal = N;\n"
"    output.tangent = dPu;\n"
"    output.bitangent = dPv;\n"
"#if OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    output.Nu = dNu;\n"
"    output.Nv = dNv;\n"
"#endif\n"
"\n"
"    output.tessCoord = UV;\n"
"    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);\n"
"\n"
"    return output;\n"
"}\n"
"\n"
"#if USE_STAGE_IN\n"
"template<typename PerPatchVertexGregoryBasis>\n"
"#endif\n"
"OsdPatchVertex OsdComputePatch(\n"
"        float tessLevel,\n"
"        float2 domainCoord,\n"
"        unsigned patchID,\n"
"#if USE_STAGE_IN\n"
"        PerPatchVertexGregoryBasis osdPatch\n"
"#else\n"
"        OsdVertexBufferSet osdBuffers\n"
"#endif\n"
"        )\n"
"{\n"
"    return ds_gregory_patches(\n"
"            tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"#if USE_STAGE_IN\n"
"            osdPatch.tessOuterLo,\n"
"            osdPatch.tessOuterHi,\n"
"#else\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterLo,\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterHi,\n"
"#endif\n"
"#endif\n"
"#if USE_STAGE_IN\n"
"            osdPatch.cv,\n"
"            osdPatch.patchParam,\n"
"#else\n"
"            osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"            osdBuffers.patchParamBuffer[patchID],\n"
"#endif\n"
"            domainCoord);\n"
"}\n"
"\n"
