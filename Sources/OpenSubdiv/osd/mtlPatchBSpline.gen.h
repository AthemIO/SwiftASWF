"#line 0 \"osd/mtlPatchBSpline.metal\"\n"
"\n"
"//\n"
"//   Copyright 2015 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BSpline.Hull\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerVertex(\n"
"        float4 position,\n"
"        threadgroup HullVertex& hullVertex,\n"
"        int vertexId,\n"
"        float4x4 modelViewProjectionMatrix,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    hullVertex.position = position;\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    float4 clipPos = mul(modelViewProjectionMatrix, position);\n"
"    short3 clip0 = short3(clipPos.x < clipPos.w,\n"
"                          clipPos.y < clipPos.w,\n"
"                          clipPos.z < clipPos.w);\n"
"    short3 clip1 = short3(clipPos.x > -clipPos.w,\n"
"                          clipPos.y > -clipPos.w,\n"
"                          clipPos.z > -clipPos.w);\n"
"    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);\n"
"#endif\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BSpline.Factors\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchBSplineFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        device OsdPerPatchVertexBezier* patch,\n"
"#if !USE_PTVS_FACTORS\n"
"        device OsdPerPatchTessFactors& patchFactors,\n"
"#endif\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    float4 tessLevelOuter = float4(0);\n"
"    float2 tessLevelInner = float2(0);\n"
"    float4 tessOuterLo = float4(0);\n"
"    float4 tessOuterHi = float4(0);\n"
"\n"
"#if OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    OsdEvalPatchBezierTessLevels(\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        patch,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#else\n"
"    OsdGetTessLevelsUniform(\n"
"        tessLevel,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#endif\n"
"\n"
"    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];\n"
"    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];\n"
"    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];\n"
"    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];\n"
"    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];\n"
"    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];\n"
"#if !USE_PTVS_FACTORS\n"
"    patchFactors.tessOuterLo = tessOuterLo;\n"
"    patchFactors.tessOuterHi = tessOuterHi;\n"
"#endif\n"
"}\n"
"\n"
"void OsdComputePerPatchFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        unsigned patchID,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        OsdPatchParamBufferSet osdBuffer,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    OsdComputePerPatchBSplineFactors(\n"
"        patchParam,\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        osdBuffer.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"#if !USE_PTVS_FACTORS\n"
"        osdBuffer.patchTessBuffer[patchID],\n"
"#endif\n"
"        quadFactors\n"
"        );\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BSpline.Vertex\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchVertex(\n"
"        int3 patchParam,\n"
"        unsigned ID,\n"
"        unsigned PrimitiveID,\n"
"        unsigned ControlID,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    OsdComputePerPatchVertexBSpline(patchParam, ID,\n"
"        patchVertices, osdBuffers.perPatchVertexBuffer[ControlID]);\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BSpline.Domain\n"
"//----------------------------------------------------------\n"
"\n"
"template<typename PerPatchVertexBezier>\n"
"OsdPatchVertex ds_regular_patches(\n"
"        const float tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"        float4 tessOuterLo,\n"
"        float4 tessOuterHi,\n"
"#endif\n"
"        PerPatchVertexBezier cv,\n"
"        int3 patchParam,\n"
"        float2 domainCoord\n"
"        )\n"
"{\n"
"#if USE_PTVS_FACTORS\n"
"    float4 tessOuterLo(0), tessOuterHi(0);\n"
"    OsdGetTessLevelsUniform(tessLevel, patchParam, tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"    float2 UV = OsdGetTessParameterization(domainCoord,\n"
"                                           tessOuterLo,\n"
"                                           tessOuterHi);\n"
"\n"
"    OsdPatchVertex output;\n"
"\n"
"    float3 P = float3(0), dPu = float3(0), dPv = float3(0);\n"
"    float3 N = float3(0), dNu = float3(0), dNv = float3(0);\n"
"    float2 vSegments = float2(0);\n"
"\n"
"    OsdEvalPatchBezier(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv, vSegments);\n"
"\n"
"    output.normal = N;\n"
"    output.tangent = dPu;\n"
"    output.bitangent = dPv;\n"
"#if OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    output.Nu = dNu;\n"
"    output.Nv = dNv;\n"
"#endif\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    output.vSegments = vSegments;\n"
"#endif\n"
"\n"
"    output.tessCoord = UV;\n"
"    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);\n"
"    output.position = P;\n"
"    return output;\n"
"}\n"
"\n"
"#if USE_STAGE_IN\n"
"template<typename PerPatchVertexBezier>\n"
"#endif\n"
"OsdPatchVertex OsdComputePatch(\n"
"        float tessLevel,\n"
"        float2 domainCoord,\n"
"        unsigned patchID,\n"
"#if USE_STAGE_IN\n"
"        PerPatchVertexBezier osdPatch\n"
"#else\n"
"        OsdVertexBufferSet osdBuffers\n"
"#endif\n"
"        )\n"
"{\n"
"    return ds_regular_patches(\n"
"            tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"#if USE_STAGE_IN\n"
"            osdPatch.tessOuterLo,\n"
"            osdPatch.tessOuterHi,\n"
"#else\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterLo,\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterHi,\n"
"#endif\n"
"#endif\n"
"#if USE_STAGE_IN\n"
"            osdPatch.cv,\n"
"            osdPatch.patchParam,\n"
"#else\n"
"            osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"            osdBuffers.patchParamBuffer[patchID],\n"
"#endif\n"
"            domainCoord\n"
"            );\n"
"}\n"
"\n"
"\n"
